---
title: "Summary of work by week 9"
author: "Helene Behrens"
date: "3/3/2021"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
So far, we have tried to see if it is possible to fit a Lee-Carter model for mortality predicions and the Lee-Carter model extended with a birth-year cohort effect using inlabru. The first results are good, but we have only tested the model for synthetic data, which are not necessarily very close to the real-life situation. 

## The Lee-Carter model
We have used the follwing version of the Lee-Carter model:
$$
Y_{x,t} \sim Poisson(E_{x,t}\cdot e^{\eta_{x,t}}), 
$$
where $Y_{x,t}$ is the expected number of deaths for people at age $x$ in year $t$, $E_{x,t}$ is the number of people "at risk" (observed people) of age $x$ at time $t$ and 
$$
\eta_{x,t}= C + \alpha_x + \beta_x\cdot\kappa_t + \epsilon_{x,t}.
$$
Here $\alpha_x$ can be interpreted as the overall mortality profile for the ages in $x$, $\kappa_t$ is the change in mortality for different times $t$, relative to a zero-level and $\beta_x$ can be interpreted as the sensitivity to time-related changes in mortality for different ages $x$. $\epsilon_{x,t}$ is the error term, assumed to be normal distributed with zero mean, and $C$ is a constant. $\alpha_x$, $\beta_x$ and $\kappa_t$ are subject to the following constraints:
$$
\sum_x \alpha_x = 0, \quad \sum_x\beta_x = 1, \quad \sum_t\kappa_t = 0.
$$
We have modeled $\alpha_x$ as a random walk, $\beta_x$ as iid normal distributed with zero mean and $\kappa_t$ as a random walk with drift:
$$
\kappa_{t+1} = \phi + \kappa_{t} + \epsilon_{\kappa}, \quad \epsilon_{\kappa} \sim N(0,1/\tau_\kappa).
$$
As inla only handles latent effects modelled as random walks without drift, we rewrite to be able to run with inla:
$$
\kappa_t = \kappa^*_t + \phi\cdot t, \quad \kappa^*_t = \kappa^*_{t-1} + \epsilon_{\kappa}, \quad \sum_t\kappa^*_t = 0.
$$
Our model is then
$$
\eta_{x,t} = C + \alpha_x + \beta_x\cdot\phi\cdot t + \beta_x\kappa_t^* + \epsilon.
$$
From this point, we will refer to $\kappa_t^*$ as only $\kappa_t$. We have also tried to include a cohort-effect of a persons birth-year, $t-x$, to our model:
$$
\eta_{x,t} = C + \alpha_x + \beta_x\cdot\phi\cdot t + \beta_x \cdot \kappa_t + \gamma_{t-x} + \epsilon,
$$
where $\gamma_{t-x}$ is the cohort effect subject to the constraint $\sum_{x,t}\gamma_{t-x} = 0$ and the remaining parameters are the same as before. We have modeled $\gamma_{t-x}$ as a random walk. 

## Using Inlabru
The multiplicative term $\beta_x\cdot\kappa_t$ makes the predictor $\eta_{x,t}$ non-linear, which means that Inla can not be used to do inference of data following this model. We have tried to use the Inlabru package in R to get around this obstacle.

Inlabru uses a Taylor approximation to linearize the predictor $\eta_{x,t}$ and then runs Inla with this linearization as the linear predictor. 

To find the ideal linearization point, Inlabru runs a fix-point iteration with Inla, setting the linearization point in one step as the point that maximize the posterior distribution of the latent effects that results when running inla with the linearization point from the last step. For further explanation, see https://inlabru-org.github.io/inlabru/articles/method.html or the last part of this document. 

Below are some examples of inference with Inlabru on our model. We have used synthetic data, so we have sampled values of the latent effects from different functions for $\alpha_x$, $\beta_x$, $\kappa_t$ and $\phi$.  In general, we get a good model fit for most model choices, and Inlabru fits the values of the non-linear predictor $\eta_{x,t}$ well in all cases.

For some combinations of $\kappa_t$ and $\phi$, it does seem like the model gets unidentifiable. We also observe that introducing the cohort effect $\gamma_{t-x}$ seems to amplify this effect somewhat. However, the combination of $\phi$ and $\kappa_t$ that causes problems are not very likely to be observed in real life, given the assmption that $\kappa_t$ is a random walk without drift and $\phi$ is the drift. Also, we do not see any indication that $\gamma_{t-x}$ itself causes any unidenitfyability problems with any of the other effects. 

Below, I have included the implementation of running inlabru for four different configurations for the latent effects. 
```{r, results='hide'}
library(INLA)
library(inlabru)
library(ggplot2)
library(patchwork)
library(tidyverse)
```

```{r, results='hide'}
seed = 324
set.seed(seed)

N = 1000   #  Number of observations

general.title = paste("N = ", N, "seed = ", seed)   #  Used to identify plots

nx = 10   #  x from 1 to nx
nt = 10   #  t from 1 to nt

at.risk = 1000   #  number of people at risk for each x-t-pair, here as a constant

x = sample(1:nx, N, replace = TRUE)   
t = sample(1:nt, N, replace = TRUE)   

tau.iid = 1/0.1**2   #  Standard deviation of 0.1 for the iid effects (beta)
tau.epsilon = 1/0.01**2   #  Standard deviation of 0.01 for the error term 

# sample beta_x, same for all configurations of the latent effects
beta = rnorm(nx, 0, sqrt(1/tau.iid))
beta = 1/nx + beta - mean(beta)   # sum to 1

```
The following configuration of the latent effects seem to be easy for inlabru to fit. Here we have not included the cohort effect. 

```{r, results='hide'}
#   underlying models for latent effects:
kappa = 0.5*cos((1:nt)*pi/3)  
kappa = kappa - mean(kappa)   #  shift around zero

alpha = cos(((1:nx - 3)* pi)/6)
alpha = alpha - mean(alpha)   #  shift around zero

phi = -0.5  

#  sample synthetic data and arrange observations in the obs dataframe
obs = data.frame(x,t)
obs = obs %>% 
  mutate(beta = beta[as.vector(obs$x)],
         kappa = kappa[as.vector(obs$t)],
         alpha = alpha[as.vector(obs$x)],
         phi.t = phi*obs$t,
         phi = phi,
         at.risk = at.risk,
         epsilon = rnorm(n = N, 0, sqrt(1/tau.epsilon))) %>%
  mutate(eta = alpha + beta*phi.t + beta*kappa + epsilon) %>%   #  linear predictor
  mutate(y.o = rpois(N, at.risk*exp(eta))) %>%   #  simulate data
  mutate(t1 = t, x1 = x)  %>%   #  add extra t and x to the observations for the sake of inlabru:
  mutate(xt = seq_along(t))

#   ----  Start defining the inlabru model components  ----   

#  helper values for constraining of beta:
A.mat = matrix(1, nrow = 1, ncol = nx)
e.vec = 1

#  add more inforamative priors
pc.prior <- list(prec = list(prior = "pc.prec", param = c(0.3,0.8)))
pc.alpha <- list(prec = list(prior = "pc.prec", param = c(0.1,0.1)))
pc.prior.small <- list(prec = list(prior = "pc.prec", param = c(0.02, 0.1)))

#  define the components of the model
comp = ~ -1 + 
  Int(1) + 
  alpha(x, model = "rw1", constr = TRUE, hyper = pc.alpha) + 
  phi(t, model = "linear", prec.linear = 1) +
  beta(x1, model = "iid", extraconstr = list(A = A.mat, e = e.vec)) + 
  kappa(t1, model = "rw1", values = 1:nt, constr = TRUE, hyper = pc.prior) +
  epsilon(xt, model = "iid", hyper = pc.prior.small)

#  define the likelihood
form.1 = y.o ~ -1 + Int + alpha + beta*phi + beta*kappa + epsilon
likelihood.1 = like(formula = form.1, family = "poisson", data = obs, E = at.risk)

c.c <- list(cpo = TRUE, dic = TRUE, waic = TRUE, config = TRUE)  #  control compute

# run inlabru
res = bru(components = comp,
          likelihood.1, 
          options = list(verbose = F,
                         #bru_verbose = 1, 
                         num.threads = "1:1",
                         control.compute = c.c
                         )) 

# would in a script only rerun if necessary
#res = bru_rerun(res)
```
```{r, echo=FALSE}
#   ----   Displaying results   ----

cat(general.title)
res$summary.fixed
res$summary.hyperpar

data.alpha = cbind(res$summary.random$alpha, alpha.true = alpha[res$summary.random$alpha$ID])
gg.alpha <- ggplot(data = data.alpha, aes(x = ID)) + 
  geom_ribbon(aes(ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_point(aes(y = mean, color = "Estimated")) + 
  geom_point(aes(y = alpha.true, color = "True value")) + 
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) +
  ggtitle(paste("Alpha: ", general.title))

data.beta = cbind(res$summary.random$beta, beta.true = beta[res$summary.random$beta$ID])
gg.beta <- ggplot(data = data.beta) + 
  geom_ribbon(aes(x = ID, ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_point(aes(x = ID, y = mean, color = "Estimated")) + 
  geom_point(aes(x = ID, y = beta.true, color = "True value")) +
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) + 
  ggtitle(paste("Beta: ", general.title))

data.kappa = cbind(res$summary.random$kappa, kappa.true = kappa[res$summary.random$kappa$ID])
gg.kappa <- ggplot(data = data.kappa, aes(x = ID)) + 
  geom_ribbon(aes(ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_point(aes(y = mean, color = "Estimated")) + 
  geom_point(aes(y = kappa.true, color = "True value")) + 
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) + 
  ggtitle(paste("Kappa: ", general.title))

data.phi = data.frame(cbind(ID = 1:nt, 
                 mean = res$summary.fixed$mean[2]*1:nt,
                 X0.025quant = res$summary.fixed$`0.025quant`[2]*1:nt,
                 X0.975quant = res$summary.fixed$`0.975quant`[2]*1:nt,
                 phi.true = phi*1:nt))
gg.phi <- ggplot(data = data.phi, aes(x = ID)) + 
  geom_ribbon(aes(ymin = X0.025quant, ymax = X0.975quant), fill = "lightskyblue1") + 
  geom_point(aes(y = mean, color = "Estimated")) + 
  geom_point(aes(y = phi.true, color = "True value")) + 
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) + 
  ggtitle(paste("Phi: ", general.title))

# density plot of true eta and predicted eta:
data.eta <- data.frame(eta.sim = res$summary.linear.predictor$mean[1:N], true.eta = obs$eta) 
gg.eta <- ggplot(data.eta) + geom_point(aes(x = eta.sim, y = true.eta)) + 
  ggtitle(paste("Eta: ", general.title))

(gg.alpha | gg.beta)
(gg.kappa | gg.phi)
gg.eta

```
The next configuration shows good results for the estimation of the predictior $\eta$, but a mix-up in the estimation of $\kappa_t$ and $\phi$. This model is also without the cohort effect. We have used the same code as above, only changing the function used for $\kappa_t$.

```{r}
#   underlying models for latent effects:
kappa = cos((1:nt)*pi/20)  
kappa = kappa - mean(kappa)   #  shift around zero
```
```{r, echo = FALSE, results='hide'}

alpha = cos(((1:nx - 3)* pi)/6)
alpha = alpha - mean(alpha)   #  shift around zero

phi = -0.5  

#  sample synthetic data and arrange observations in the obs dataframe
obs = data.frame(x,t)
obs = obs %>% 
  mutate(beta = beta[as.vector(obs$x)],
         kappa = kappa[as.vector(obs$t)],
         alpha = alpha[as.vector(obs$x)],
         phi.t = phi*obs$t,
         phi = phi,
         at.risk = at.risk,
         epsilon = rnorm(n = N, 0, sqrt(1/tau.epsilon))) %>%
  mutate(eta = alpha + beta*phi.t + beta*kappa + epsilon) %>%   #  linear predictor
  mutate(y.o = rpois(N, at.risk*exp(eta))) %>%   #  simulate data
  mutate(t1 = t, x1 = x)  %>%   #  add extra t and x to the observations for the sake of inlabru:
  mutate(xt = seq_along(t))

#   ----  Start defining the inlabru model components  ----   

#  helper values for constraining of beta:
A.mat = matrix(1, nrow = 1, ncol = nx)
e.vec = 1

#  add more inforamative priors
pc.prior <- list(prec = list(prior = "pc.prec", param = c(0.3,0.8)))
pc.alpha <- list(prec = list(prior = "pc.prec", param = c(0.1,0.1)))
pc.prior.small <- list(prec = list(prior = "pc.prec", param = c(0.02, 0.1)))

#  define the components of the model
comp = ~ -1 + 
  Int(1) + 
  alpha(x, model = "rw1", constr = TRUE, hyper = pc.alpha) + 
  phi(t, model = "linear", prec.linear = 1) +
  beta(x1, model = "iid", extraconstr = list(A = A.mat, e = e.vec)) + 
  kappa(t1, model = "rw1", values = 1:nt, constr = TRUE, hyper = pc.prior) +
  epsilon(xt, model = "iid", hyper = pc.prior.small)

#  define the likelihood
form.1 = y.o ~ -1 + Int + alpha + beta*phi + beta*kappa + epsilon
likelihood.1 = like(formula = form.1, family = "poisson", data = obs, E = at.risk)

c.c <- list(cpo = TRUE, dic = TRUE, waic = TRUE, config = TRUE)  #  control compute

# run inlabru
res = bru(components = comp,
          likelihood.1, 
          options = list(verbose = F,
                         #bru_verbose = 1, 
                         num.threads = "1:1",
                         control.compute = c.c
                         )) 

# would in a script only rerun if necessary
#res = bru_rerun(res)
```

```{r, echo = FALSE}
#   ----   Displaying results   ----

cat(general.title)
res$summary.fixed
res$summary.hyperpar

data.alpha = cbind(res$summary.random$alpha, alpha.true = alpha[res$summary.random$alpha$ID])
gg.alpha <- ggplot(data = data.alpha, aes(x = ID)) + 
  geom_ribbon(aes(ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_point(aes(y = mean, color = "Estimated")) + 
  geom_point(aes(y = alpha.true, color = "True value")) + 
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) +
  ggtitle(paste("Alpha: ", general.title))

data.beta = cbind(res$summary.random$beta, beta.true = beta[res$summary.random$beta$ID])
gg.beta <- ggplot(data = data.beta) + 
  geom_ribbon(aes(x = ID, ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_point(aes(x = ID, y = mean, color = "Estimated")) + 
  geom_point(aes(x = ID, y = beta.true, color = "True value")) +
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) + 
  ggtitle(paste("Beta: ", general.title))

data.kappa = cbind(res$summary.random$kappa, kappa.true = kappa[res$summary.random$kappa$ID])
gg.kappa <- ggplot(data = data.kappa, aes(x = ID)) + 
  geom_ribbon(aes(ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_point(aes(y = mean, color = "Estimated")) + 
  geom_point(aes(y = kappa.true, color = "True value")) + 
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) + 
  ggtitle(paste("Kappa: ", general.title))

data.phi = data.frame(cbind(ID = 1:nt, 
                 mean = res$summary.fixed$mean[2]*1:nt,
                 X0.025quant = res$summary.fixed$`0.025quant`[2]*1:nt,
                 X0.975quant = res$summary.fixed$`0.975quant`[2]*1:nt,
                 phi.true = phi*1:nt))
gg.phi <- ggplot(data = data.phi, aes(x = ID)) + 
  geom_ribbon(aes(ymin = X0.025quant, ymax = X0.975quant), fill = "lightskyblue1") + 
  geom_point(aes(y = mean, color = "Estimated")) + 
  geom_point(aes(y = phi.true, color = "True value")) + 
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) + 
  ggtitle(paste("Phi: ", general.title))

# density plot of true eta and predicted eta:
data.eta <- data.frame(eta.sim = res$summary.linear.predictor$mean[1:N], true.eta = obs$eta) 
gg.eta <- ggplot(data.eta) + geom_point(aes(x = eta.sim, y = true.eta)) + 
  ggtitle(paste("Eta: ", general.title))

(gg.alpha | gg.beta)
(gg.kappa | gg.phi)
gg.eta

```

In the following configuration, we have included the cohort effect. We observe how the introduction of the cohort effect amplifies the error from the last example.
```{r, results='hide'}
#   underlying models for latent effects:
kappa = cos((1:nt)*pi/20)  
kappa = kappa - mean(kappa)   #  shift around zero

alpha = cos(((1:nx - 3)* pi)/6)
alpha = alpha - mean(alpha)   #  shift around zero

# define max and min of the values for the cohort
n.cohort = (nt - 1) + abs(1-nx) + 1
cohort.min = 1-nx
cohort.max = nt-1

# get samples for the cohorts
cohort = t-x

gamma = 0.2*(cohort.min:cohort.max) + sin(cohort.min:cohort.max)
gamma = gamma - mean(gamma)  #center around zero

phi = -0.5  

#  sample synthetic data and arrange observations in the obs dataframe
obs = data.frame(x,t, cohort)
obs = obs %>% 
  mutate(beta = beta[as.vector(obs$x)],
         kappa = kappa[as.vector(obs$t)],
         alpha = alpha[as.vector(obs$x)],
         gamma = gamma[as.vector(obs$cohort - cohort.min + 1)],
         phi.t = phi*obs$t,
         phi = phi,
         at.risk = at.risk,
         epsilon = rnorm(n = N, 0, sqrt(1/tau.epsilon))) %>%
  mutate(eta = alpha + beta*phi.t + beta*kappa + gamma + epsilon) %>%   #  linear predictor
  mutate(y.o = rpois(N, at.risk*exp(eta))) %>%   #  simulate data
  mutate(t1 = t, x1 = x)  %>%   #  add extra t and x to the observations for the sake of inlabru:
  mutate(xt = seq_along(t))

#   ----  Start defining the inlabru model components  ----   

#  helper values for constraining of beta:
A.mat = matrix(1, nrow = 1, ncol = nx)
e.vec = 1

#  add more inforamative priors
pc.prior <- list(prec = list(prior = "pc.prec", param = c(0.3,0.8)))
pc.alpha <- list(prec = list(prior = "pc.prec", param = c(0.1,0.1)))
pc.prior.small <- list(prec = list(prior = "pc.prec", param = c(0.02, 0.1)))
pc.prior.gamma <- list(prec = list(prior = "pc.prec", param = c(0.8, 0.8)))


#  define the components of the model
comp = ~ -1 + 
  Int(1) + 
  alpha(x, model = "rw1", constr = TRUE, hyper = pc.alpha) + 
  phi(t, model = "linear", prec.linear = 1) +
  beta(x1, model = "iid", extraconstr = list(A = A.mat, e = e.vec)) + 
  kappa(t1, model = "rw1", values = 1:nt, constr = TRUE, hyper = pc.prior) +
  gamma(cohort, model = "rw1", values = cohort.min:cohort.max, constr = TRUE, hyper = pc.prior.gamma) + 
  epsilon(xt, model = "iid", hyper = pc.prior.small)

#  define the likelihood
form.1 = y.o ~ -1 + Int + alpha + beta*phi + beta*kappa + gamma + epsilon
likelihood.1 = like(formula = form.1, family = "poisson", data = obs, E = at.risk)

c.c <- list(cpo = TRUE, dic = TRUE, waic = TRUE, config = TRUE)  #  control compute

# run inlabru
res = bru(components = comp,
          likelihood.1, 
          options = list(verbose = F,
                         #bru_verbose = 1, 
                         num.threads = "1:1",
                         control.compute = c.c
                         )) 

# would in a script only rerun if necessary
#res = bru_rerun(res)
```
```{r, echo = FALSE}
#   ----   Displaying results   ----

cat(general.title)
res$summary.fixed
res$summary.hyperpar

data.alpha = cbind(res$summary.random$alpha, alpha.true = alpha[res$summary.random$alpha$ID])
gg.alpha <- ggplot(data = data.alpha, aes(x = ID)) + 
  geom_ribbon(aes(ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_point(aes(y = mean, color = "Estimated")) + 
  geom_point(aes(y = alpha.true, color = "True value")) + 
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) +
  ggtitle(paste("Alpha: ", general.title))

data.beta = cbind(res$summary.random$beta, beta.true = beta[res$summary.random$beta$ID])
gg.beta <- ggplot(data = data.beta) + 
  geom_ribbon(aes(x = ID, ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_point(aes(x = ID, y = mean, color = "Estimated")) + 
  geom_point(aes(x = ID, y = beta.true, color = "True value")) +
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) + 
  ggtitle(paste("Beta: ", general.title))

data.kappa = cbind(res$summary.random$kappa, kappa.true = kappa[res$summary.random$kappa$ID])
gg.kappa <- ggplot(data = data.kappa, aes(x = ID)) + 
  geom_ribbon(aes(ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_point(aes(y = mean, color = "Estimated")) + 
  geom_point(aes(y = kappa.true, color = "True value")) + 
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) + 
  ggtitle(paste("Kappa: ", general.title))

data.gamma = cbind(res$summary.random$gamma, gamma.true = gamma[res$summary.random$gamma$ID - cohort.min + 1])
gg.gamma <- ggplot(data = data.gamma, aes(x = ID)) + 
  geom_ribbon(aes(ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_line(aes(y = mean), color = "lightskyblue") + 
  geom_point(aes(y = gamma.true), color = "dodgerblue1") + 
  ggtitle(paste("Gamma: ", general.title))

data.phi = data.frame(cbind(ID = 1:nt, 
                 mean = res$summary.fixed$mean[2]*1:nt,
                 X0.025quant = res$summary.fixed$`0.025quant`[2]*1:nt,
                 X0.975quant = res$summary.fixed$`0.975quant`[2]*1:nt,
                 phi.true = phi*1:nt))
gg.phi <- ggplot(data = data.phi, aes(x = ID)) + 
  geom_ribbon(aes(ymin = X0.025quant, ymax = X0.975quant), fill = "lightskyblue1") + 
  geom_point(aes(y = mean, color = "Estimated")) + 
  geom_point(aes(y = phi.true, color = "True value")) + 
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) + 
  ggtitle(paste("Phi: ", general.title))

# density plot of true eta and predicted eta:
data.eta <- data.frame(eta.sim = res$summary.linear.predictor$mean[1:N], true.eta = obs$eta) 
gg.eta <- ggplot(data.eta) + geom_point(aes(x = eta.sim, y = true.eta)) + 
  ggtitle(paste("Eta: ", general.title))

(gg.alpha | gg.beta)
(gg.kappa | gg.phi)
(gg.gamma | gg.eta)

```

The last example also includes the cohort effect. It shows that given a well-defined combination of $\kappa_t$ and $\phi$, Inlabru is also able to fit the latent effects, including the cohort effect. For this example, we have run the previous code, only changing the function used for $\kappa_t$. 

```{r}
#   underlying models for latent effects:
kappa = 0.5*cos((1:nt)*pi/3)  
kappa = kappa - mean(kappa)   #  shift around zero

```
```{r, echo = FALSE, results='hide'}

alpha = cos(((1:nx - 3)* pi)/6)
alpha = alpha - mean(alpha)   #  shift around zero

# define max and min of the values for the cohort
n.cohort = (nt - 1) + abs(1-nx) + 1
cohort.min = 1-nx
cohort.max = nt-1

# get samples for the cohorts
cohort = t-x

gamma = 0.2*(cohort.min:cohort.max) + sin(cohort.min:cohort.max)
gamma = gamma - mean(gamma)  #center around zero

phi = -0.5  

#  sample synthetic data and arrange observations in the obs dataframe
obs = data.frame(x,t, cohort)
obs = obs %>% 
  mutate(beta = beta[as.vector(obs$x)],
         kappa = kappa[as.vector(obs$t)],
         alpha = alpha[as.vector(obs$x)],
         gamma = gamma[as.vector(obs$cohort - cohort.min + 1)],
         phi.t = phi*obs$t,
         phi = phi,
         at.risk = at.risk,
         epsilon = rnorm(n = N, 0, sqrt(1/tau.epsilon))) %>%
  mutate(eta = alpha + beta*phi.t + beta*kappa + gamma + epsilon) %>%   #  linear predictor
  mutate(y.o = rpois(N, at.risk*exp(eta))) %>%   #  simulate data
  mutate(t1 = t, x1 = x)  %>%   #  add extra t and x to the observations for the sake of inlabru:
  mutate(xt = seq_along(t))

#   ----  Start defining the inlabru model components  ----   

#  helper values for constraining of beta:
A.mat = matrix(1, nrow = 1, ncol = nx)
e.vec = 1

#  add more inforamative priors
pc.prior <- list(prec = list(prior = "pc.prec", param = c(0.3,0.8)))
pc.alpha <- list(prec = list(prior = "pc.prec", param = c(0.1,0.1)))
pc.prior.small <- list(prec = list(prior = "pc.prec", param = c(0.02, 0.1)))
pc.prior.gamma <- list(prec = list(prior = "pc.prec", param = c(0.8, 0.8)))


#  define the components of the model
comp = ~ -1 + 
  Int(1) + 
  alpha(x, model = "rw1", constr = TRUE, hyper = pc.alpha) + 
  phi(t, model = "linear", prec.linear = 1) +
  beta(x1, model = "iid", extraconstr = list(A = A.mat, e = e.vec)) + 
  kappa(t1, model = "rw1", values = 1:nt, constr = TRUE, hyper = pc.prior) +
  gamma(cohort, model = "rw1", values = cohort.min:cohort.max, constr = TRUE, hyper = pc.prior.gamma) + 
  epsilon(xt, model = "iid", hyper = pc.prior.small)

#  define the likelihood
form.1 = y.o ~ -1 + Int + alpha + beta*phi + beta*kappa + gamma + epsilon
likelihood.1 = like(formula = form.1, family = "poisson", data = obs, E = at.risk)

c.c <- list(cpo = TRUE, dic = TRUE, waic = TRUE, config = TRUE)  #  control compute

# run inlabru
res = bru(components = comp,
          likelihood.1, 
          options = list(verbose = F,
                         #bru_verbose = 1, 
                         num.threads = "1:1",
                         control.compute = c.c
                         )) 

# would in a script only rerun if necessary
#res = bru_rerun(res)
```
```{r, echo=FALSE}
#   ----   Displaying results   ----

cat(general.title)
res$summary.fixed
res$summary.hyperpar

data.alpha = cbind(res$summary.random$alpha, alpha.true = alpha[res$summary.random$alpha$ID])
gg.alpha <- ggplot(data = data.alpha, aes(x = ID)) + 
  geom_ribbon(aes(ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_point(aes(y = mean, color = "Estimated")) + 
  geom_point(aes(y = alpha.true, color = "True value")) + 
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) +
  ggtitle(paste("Alpha: ", general.title))

data.beta = cbind(res$summary.random$beta, beta.true = beta[res$summary.random$beta$ID])
gg.beta <- ggplot(data = data.beta) + 
  geom_ribbon(aes(x = ID, ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_point(aes(x = ID, y = mean, color = "Estimated")) + 
  geom_point(aes(x = ID, y = beta.true, color = "True value")) +
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) + 
  ggtitle(paste("Beta: ", general.title))

data.kappa = cbind(res$summary.random$kappa, kappa.true = kappa[res$summary.random$kappa$ID])
gg.kappa <- ggplot(data = data.kappa, aes(x = ID)) + 
  geom_ribbon(aes(ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_point(aes(y = mean, color = "Estimated")) + 
  geom_point(aes(y = kappa.true, color = "True value")) + 
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) + 
  ggtitle(paste("Kappa: ", general.title))

data.gamma = cbind(res$summary.random$gamma, gamma.true = gamma[res$summary.random$gamma$ID - cohort.min + 1])
gg.gamma <- ggplot(data = data.gamma, aes(x = ID)) + 
  geom_ribbon(aes(ymin = `0.025quant`, ymax = `0.975quant`), fill = "lightskyblue1") + 
  geom_line(aes(y = mean), color = "lightskyblue") + 
  geom_point(aes(y = gamma.true), color = "dodgerblue1") + 
  ggtitle(paste("Gamma: ", general.title))

data.phi = data.frame(cbind(ID = 1:nt, 
                 mean = res$summary.fixed$mean[2]*1:nt,
                 X0.025quant = res$summary.fixed$`0.025quant`[2]*1:nt,
                 X0.975quant = res$summary.fixed$`0.975quant`[2]*1:nt,
                 phi.true = phi*1:nt))
gg.phi <- ggplot(data = data.phi, aes(x = ID)) + 
  geom_ribbon(aes(ymin = X0.025quant, ymax = X0.975quant), fill = "lightskyblue1") + 
  geom_point(aes(y = mean, color = "Estimated")) + 
  geom_point(aes(y = phi.true, color = "True value")) + 
  scale_color_manual(name = "Method",
                     breaks = c("Estimated", "True value"),
                     values = c("Estimated" = "lightskyblue", "True value" = "dodgerblue1") ) + 
  ggtitle(paste("Phi: ", general.title))

# density plot of true eta and predicted eta:
data.eta <- data.frame(eta.sim = res$summary.linear.predictor$mean[1:N], true.eta = obs$eta) 
gg.eta <- ggplot(data.eta) + geom_point(aes(x = eta.sim, y = true.eta)) + 
  ggtitle(paste("Eta: ", general.title))

(gg.alpha | gg.beta)
(gg.kappa | gg.phi)
(gg.gamma | gg.eta)

```

## Inlabru - further explanation. 

We have a non-linear predictor $\eta_{x,t}$ that is a function of some latent effects, $\textbf{u}$:
$$
\eta_{x,t} = C + \alpha_x, \phi\cdot t\cdot \beta_x + \beta_x\cdot\kappa_t + \epsilon, \quad \textbf{u} = [\alpha_1,...,\alpha_{N_x},\beta_1,...,\beta_{N_x},\phi,\kappa_1,...,\kappa_{N_t}].
$$
Using a Taylor approximation around some point $\textbf{u}_0$ one gets
$$
\bar{\boldsymbol{\eta}} = \boldsymbol{\eta}_{x,t}(\textbf{u}_0) + B(\textbf{u} - \textbf{u}_0),
$$
where $B$ is the derivative matrix of $\boldsymbol{\eta}$ evaluated at $\textbf{u}_0$. This linearized predictor is then used to run inla, and we obtain approximate marginal posterior distributions for the latent effects, hyperparameters and the predictor $\eta_{x,t}$. 
Inlabru finds the optimal linearization point $\textbf{u}_0$ through a fixed-point iteration with inla. For each step $s$, the next linearization point $\textbf{u}_s$ is set to the point that maximizes the posterior distribution for the latent effects that resulted from the inla approximation using the linearization from the last step $\textbf{u}_{s-1}$:
$$
\textbf{u}_{s} = \text{argmax}_{\textbf{u}}\,\,\bar{p}_{\textbf{u}_{s-1}}(\textbf{u}\mid \textbf{y}, \hat{\boldsymbol{\theta}}) =: f(\bar{p}_{\textbf{u}_{s-1}}), \quad \hat{\boldsymbol{\theta}} = \text{argmax}_{\boldsymbol{\theta}}\,\,\bar{p}_{\textbf{u}_{s-1}}(\boldsymbol{\theta}\mid \textbf{y}).
$$
Inlabru runs these iterations until approximate convergence:
$$
\textbf{u}_s \approx f(\bar{p}_{\textbf{u}_{s-1}}).
$$



